
from ast import arg
import pykd, sys
import argparse

parsed_buffer = []

def hex_byte(byte_str):
    """validate user input is a hex representation of an int between 0 and 255 inclusive"""
    if byte_str == "??":
        # windbg shows ?? when it can't access a memory region, but we shouldn't stop execution because of it
        return byte_str

    try:
        val = int(byte_str, 16)
        if 0 <= val <= 255:
            return val
        else:
            raise ValueError
    except ValueError:
        raise argparse.ArgumentTypeError(
            f"only *hex* bytes between 00 and ff are valid, found {byte_str}"
        )

def generate_byte_string(args):
    known_bad = ", ".join(f'{x:02X}' for x in args.bad)

    print("[+] Generating a new payload for testing")
    var_str = f"chars = bytes(i for i in range({args.start}, {args.end + 1}) if i not in [{known_bad}])"

    print("[+] characters as a range of bytes")
    print(var_str, end="\n\n")

    print("[+] characters as a byte string")

    # deliberately not using enumerate since it may not execute in certain situations depending on user input for the
    # range bounds
    counter = 0

    for i in range(args.start, args.end + 1):
        if i in args.bad:
            continue

        if i == args.start:
            # first byte
            print(f"chars  = b'\\x{i:02X}", end="")
        elif counter % 16 == 0:
            # start a new line
            print("'")
            print(f"chars += b'\\x{i:02X}", end="")
        else:
            print(f"\\x{i:02X}", end="")

        counter += 1

    if counter % 16 != 0 and counter != 0:
        print("'")


def populate_data(args):

    buffer = pykd.dbgCommand("db %s L100" % args.address)

    buffer = buffer.splitlines()
    
    for line in buffer:
        Line = line.split("  ")[1].replace("-", " ")
        line_chars = Line.split(" ")
        for char in line_chars:
            char = int(char, 16)
            parsed_buffer.append(char)
            

    print(parsed_buffer)
    validate_data(parsed_buffer, args)            


def validate_data(buffer, args):
    chars = bytes(i for i in range(args.start, args.end + 1) if i not in args.bad)
    i = 0

    for parsed in buffer:
        compare = chars[i]
        if compare == args.end: # break if we reached our last char to compare
            print("[+] No more bad char detected")
            print("[+] Full list is %s" % args.bad)
            break

        if parsed == compare:
            print(hex(parsed), hex(compare))
            i = i + 1
            continue
        else:
            if compare in args.bad:
                i = i +1 
                continue
            else:
                # print("Got From Windbg:",hex(parsed),"Got From HexTable:" ,hex(compare), "\nindex is %s" % i)
                print("[-] bad char detected: %s " % hex(compare))
                args.bad.append(compare)
                
                full = ""
                for bad in args.bad:
                    full = full + " " + hex(bad)

                print("[+] Updated bad char list is: %s "% full )

                generate_byte_string(args)

                print(".load pykd ;!py %s -a %s -s %s -b%s" % (sys.argv[0], args.address, args.start, full.replace("0x", "")))

                break


def main(args):
    if args.address is not None:
        populate_data(args)
    else:
        generate_byte_string(args)


if __name__ == "__main__":
    parser = argparse.ArgumentParser()

    parser.add_argument(
        "-s",
        "--start",
        help="hex byte from which to start searching in memory (default: 00)",
        default=0,
        type=hex_byte,
    )
    parser.add_argument(
        "-e",
        "--end",
        help="last hex byte to search for in memory (default: ff)",
        default=255,
        type=hex_byte,
    )
    parser.add_argument(
        "-b",
        "--bad",
        help="space separated list of hex bytes that are already known bad (ex: -b 00 0a 0d)",
        nargs="+",
        type=hex_byte,
        default=[],
    )

    mutuals = parser.add_mutually_exclusive_group(required=True)
    
    mutuals.add_argument(
        "-a", "--address", help="address from which to begin character comparison"
    )

    mutuals.add_argument(
        "-g",
        "--generate",
        help="generate a byte string suitable for use in source code",
        action="store_true",
    )


    parsed = parser.parse_args()

    if parsed.start > parsed.end:
        print("[!] --start value must be higher than --end; exiting...")
        raise SystemExit

    main(parsed)

    

    


